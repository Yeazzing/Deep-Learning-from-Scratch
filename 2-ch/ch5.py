# -*- coding: utf-8 -*-
"""ch5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10WNzsBSHsfWGfIyHguDV52mO42WaZBHi
"""

import numpy as np

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import sys, os
# %cd /content/drive/MyDrive/Colab Notebooks/밑바닥딥러닝2

"""RNN 계층 구현"""

class RNN:
    def __init__(self, Wx, Wh, b):
        self.params = [Wx, Wh, b]
        self.grads = [np.zeros_like(Wx), np.zeros_like(Wh), np.zeros_like(b)]
        self.cache = None

    def forward(self, x, h_prev):  #순전파
        Wx, Wh, b = self.params
        t = np.matmul(h_prev, Wh) +np.matmul(x, Wx)+b
        h_next = np.tanh(t)

        self.cashe = (x, h_prev, h_next)
        return h_next

    def backward(self, dh_next):
        dt = dh_next*(1-h_next**2)
        db = np.sum(dt, axis=0)
        dWh = np.matmul(h_prev.T, dt)
        dh_prev = np.matmul(dt, Wh.T)
        dWx = np.matmul(x.T, dt)
        dx = np.matmul(dt, Wx.T)

        self.grads[0][...] = dWx
        self.grads[1][...] = dWh
        self.grads[2][...] = db

        return dx, dh_prev

"""Time RNN 계층 구현"""

class TimeRNN:
    def __init__(self, Wx, Wh, b, stateful=False): #stateful : 은닉 상태 유지(순전파 끊지 않고 전파) 결정 인수
        self.params = [Wx, Wh, b]
        self.grads = [np.zeros_like(Wx), np.zeros_like(Wh), np.zeros_like(b)]
        self.layers = None  #다수의 RNN계층 리스트로 저장

        self.h, self.dh = None, None
        #h : forward()메서드를 불렀을 때의 마지막 RNN계층의 은닉 상태 저장
        #dh : backward()메서드를 불렀을 때 하나 앞 블록의 은닉 상태의 기울기 저장

        self.stateful = stateful

    def set_state(self, h):
        self.h = h

    def reset_state(self):
        self.h = None

    def forward(self, xs): #순전파
        Wx, Wh, b = self.params
        N, T, D = xs.shape  #미니배치 크기 : N, T개 분량의 시계열 데이터, 입력 벡터의 차원 수 : D
        D, H = Wx.shape

        self.layers=[]
        hs = np.empty((N, T, H), dtype='f')  #출력값 담을 그릇

        if not self.stateful or self.h is None:  #stateful이 false이거나 처음 호출 시
            self.h = np.zeros((N, H), dtype='f')  #0행렬로 초기화

        for t in range(T):  #T회의 RNN계층 생성
            layer = RNN(*self.params)
            self.h = layer.forward(xs[:, t, :], self.h)  #h_next
            hs[:, t, :] = self.h
            self.layers.append(layer)

        return hs

    def backward(self, dhs):
        Wx, Wh, b = self.params
        N, T, H = dhs.shape
        D, H = Wx.shape

        dxs = np.empty((N, T, D), dtype='f')  #하류로 흘려보낼 기울기를 담을 그릇
        dh =  0
        grads = [0,0,0]
        for t in reversed(range(T)):
            layer =self.layers[t]
            dx, dh = layer.backward(dhs[:, t, :]+dh)  #합산된 기울기
            #RNN의 순전파에서는 출력이 2개로 분기 (ht, ht_next) -> 역전파 시 (dht +dh_next)가 입력
            dxs[:, t, :] = dx

            for i, grad in enumerate(layer.grads):  #각 RNN계층의 가중치 기울기 합산
                grads[i] += grad

        for i, grad in enumerate(grads):
            self.grads[i][...] = grad
        self.dh = dh

        return dxs

"""RNNLM 구현"""

from common.time_layers import *

class SimpleRnnlm:
    def __init__(self, vocab_size, wordvec_size, hidden_size):
        V, D, H = vocab_size, wordvec_size, hidden_size
        rn = np.random.randn

        #가중치 초기화
        embed_W = (rn(V, D)/100).astype('f')
        rnn_Wx = (rn(D, H)/ np.sqrt(D)).astype('f')  #Xavier초깃값 이용
        rnn_Wh = (rn(H, H)/ np.sqrt(H)).astype('f')
        rnn_b = np.zeros(H).astype('f')
        affine_W = (rn(H, V)/ np.sqrt(H)).astype('f')
        affine_b = np.zeros(V).astype('f')

        #계층 생성
        self.layers = [
            TimeEmbedding(embed_W),
            TimeRNN(rnn_Wx, rnn_Wh, rnn_b, stateful=True),
            TimeAffine(affine_W, affine_b)
        ]
        self.loss_layer = TimeSoftmaxWithLoss()
        self.rnn_layer = self.layers[1]

        #모든 가중치와 기울기를 리스트에 모은다.
        self.params, self.grads = [], []
        for layer in self.layers:
            self.params +=layer.params
            self.grads += layer.grads

    def forward (self, xs, ts):
        for layer in self.layers:
            xs = layer.forward(xs)
        loss = self.loss_layer.forward(xs, ts)
        return loss

    def backward (self, dout=1):
        dout = self.loss_layer.backward(dout)
        for layer in reversed(self.layers):
            dout = layer.backward(dout)
        return dout

    def reset_state(self):
        self.rnn_layer.reset_state()

"""RNNLM의 학습 코드"""

import matplotlib.pyplot as plt
from common.optimizer import SGD
from dataset import ptb

#하이퍼파라미터 설정
batch_size = 10
wordvec_size = 100
hidden_size = 100 #RNN의 은닉 상태 벡터의 원소 수
time_size = 5 #Truncated BPTT가 한번에 펼치는 시간 크기
lr = 0.1
max_epoch = 100

#학습데이터 읽기 (전체 중 1000개만)
corpus, word_to_id, id_to_word = ptb.load_data('train')
corpus_size = 1000
corpus = corpus[:corpus_size]
vocab_size = int(max(corpus)+1)

xs = corpus[:-1]  #입력
ts = corpus[1:]  #출력 (정답 레이블)
data_size = len(xs)
print( '말뭉치 크기:%d, 어휘 수 : %d' %(corpus_size, vocab_size))

#학습 시 사용하는 변수
max_iters = data_size // (batch_size * time_size)
time_idx = 0
total_loss = 0
loss_count = 0
ppl_list = []

#모델 생성
model = SimpleRnnlm(vocab_size, wordvec_size, hidden_size)
optimizer = SGD(lr)

#1. 각 미니배치에서 샘플을 읽기 시작 위치를 계산
jump= (corpus_size -1) // batch_size
offsets = [i*jump for i in range(batch_size)]

for epoch in range(max_epoch):
    for iter in range(max_iters):
    #2. 미니배치 획득
        batch_x = np.empty((batch_size, time_size), dtype='i')
        batch_t = np.empty((batch_size, time_size), dtype='i')
        for t in range(time_size):
            for i, offset in enumerate(offsets):
                batch_x[i, t] = xs[(offset +time_idx)%data_size]  #각 미니배치
                batch_t[i, t] = ts[(offset +time_idx)%data_size]
            time_idx +=1

        #기울기를 구하여 매개변수 갱신
        loss = model.forward(batch_x, batch_t)
        model.backward()
        optimizer.update(model.params, model.grads)
        total_loss += loss
        loss_count +=1

    #3. 에폭마다 퍼플렉서티 평가
    ppl = np.exp(total_loss/loss_count)  #에폭마다 손실 평균 구하고 퍼플렉서티 구함
    print('|에폭 %d | 퍼플렉서티 %.2f' %(epoch+1, ppl))
    ppl_list.append(float(ppl))
    total_loss, loss_count = 0,0

# 그래프 그리기
x = np.arange(len(ppl_list))
plt.plot(x, ppl_list, label='train')
plt.xlabel('epochs')
plt.ylabel('perplexity')
plt.show()

##Trainger클래스 사용
from common.trainer import RnnlmTrainer
# 하이퍼파라미터 설정
batch_size = 10
wordvec_size = 100
hidden_size = 100  # RNN의 은닉 상태 벡터의 원소 수
time_size = 5  # RNN을 펼치는 크기
lr = 0.1
max_epoch = 100

# 학습 데이터 읽기
corpus, word_to_id, id_to_word = ptb.load_data('train')
corpus_size = 1000  # 테스트 데이터셋을 작게 설정
corpus = corpus[:corpus_size]
vocab_size = int(max(corpus) + 1)
xs = corpus[:-1]  # 입력
ts = corpus[1:]  # 출력（정답 레이블）

# 모델 생성
model = SimpleRnnlm(vocab_size, wordvec_size, hidden_size)
optimizer = SGD(lr)
trainer = RnnlmTrainer(model, optimizer)

trainer.fit(xs, ts, max_epoch, batch_size, time_size)  #학습 수행
#1.미니배치 순차적으로 만들어
#2.모델의 순전파와 역전파를 호출
#3.옵티마이저로 가중치를 갱신하고
#4.퍼플렉서티를 구함

trainer.plot()